import type { CreateFileReq, RequestOptions, FileObject, StreamChatReq, StreamChatData, CozeAPI } from '@coze/api';
import { MiniChatError } from "../../utils";
import { SuggestPromoteInfo } from "../../types/base/chat";
import { IChatService, ChatServiceProps } from "../../types";
import type { ChatInfo, ChatType } from "../../types";
export declare class ChatService implements IChatService {
    protected apiClient: CozeAPI;
    protected connectorId: string;
    protected appId: string;
    protected chatType: ChatType;
    constructor({ apiClient, connectorId, appId, chatType }: ChatServiceProps);
    createNewConversation(): Promise<{
        conversationId: string;
        sectionId: string;
    }>;
    createNewSection(conversationId: string): Promise<{
        sectionId: string;
    }>;
    getAppInfo(): Promise<ChatInfo>;
    getOrCreateConversationId(): Promise<{
        conversationId: string;
        sectionId: string;
    }>;
    getMessageList({ conversationId, prevCursorId, limit, }: {
        conversationId: string;
        prevCursorId?: string;
        limit?: number;
    }): Promise<{
        prevCursorId: string;
        nextCursorId: string;
        prevHasMore: boolean;
        nextHasMore: boolean;
        messages: import("@coze/api").ChatV3Message[];
    } | {
        prevCursorId: undefined;
        nextCursorId: undefined;
        prevHasMore: boolean;
        nextHasMore: boolean;
        messages: never[];
        error: MiniChatError;
    }>;
    asyncChat(params: StreamChatReq & {
        connector_id?: string;
        suggestPromoteInfo?: SuggestPromoteInfo;
    }, options?: RequestOptions): AsyncIterable<StreamChatData>;
    upload(params: CreateFileReq, options?: RequestOptions): Promise<FileObject>;
    translation(params: CreateFileReq, options?: RequestOptions): Promise<any>;
    audioSpeech(params: {
        input: string;
        voice_id: string;
        response_format?: 'wav' | 'pcm' | 'ogg' | 'opus' | 'mp3';
        speed?: number;
        sample_rate?: number;
    }): Promise<ArrayBuffer>;
    handleErrorCode(code: number): Promise<string>;
}
