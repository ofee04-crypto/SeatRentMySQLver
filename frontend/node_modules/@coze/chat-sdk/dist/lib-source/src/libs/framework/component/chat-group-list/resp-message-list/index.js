import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useMemo } from 'react';
import { getCdnUrl, logger } from "../../../../utils";
import { Spacing, MessageContent, WaitingMessage, isSupportAnswerMessage, MessageContainer, } from "../../../../ui-kit";
import { useSendMessage } from "../../../../services";
import { useChatInputStore } from "../../../../provider/context";
import { useChatInfoStore, useChatPropsStore, useI18n, useIsNeedTextToAudio, useThemeType, } from "../../../../provider";
import { usePersistCallback } from "../../../../hooks";
import { SuggestionList } from '../suggestion-list';
import { CommandCopy } from '../command/command-copy';
import { CommandAudio } from '../command/command-audio';
import { CommandTooltip } from '../command/comman-tooltip';
import styles from './index.module.less';
export const RespMessageList = ({ messages, isAWaiting, isShowSuggestion, isLastMessage, chatGroup }) => {
    const appInfo = useChatInfoStore(info => info.info);
    const cdnBaseUrlPath = useChatPropsStore(store => { var _a; return (_a = store.setting) === null || _a === void 0 ? void 0 : _a.cdnBaseUrlPath; });
    const messageUiConfigMap = useChatPropsStore(store => { var _a, _b; return (_b = (_a = store.ui) === null || _a === void 0 ? void 0 : _a.chatSlot) === null || _b === void 0 ? void 0 : _b.message; });
    const messageWrapperConf = useChatPropsStore(store => { var _a, _b; return (_b = (_a = store.ui) === null || _a === void 0 ? void 0 : _a.chatSlot) === null || _b === void 0 ? void 0 : _b.messageWrapper; });
    const answerMessages = useMemo(() => messages.filter(item => isSupportAnswerMessage(item, messageUiConfigMap)), [messages]);
    const followUpMessages = useMemo(() => messages
        .filter(item => item.type === 'follow_up' && item.content)
        .slice(0, 3), [messages]);
    if (!isAWaiting &&
        answerMessages.length === 0 &&
        followUpMessages.length === 0) {
        // 兜底
        // 没有回答
        return null;
    }
    return (_jsx(MessageContainer, Object.assign({ className: styles['resp-container'], senderInfo: {
            name: (appInfo === null || appInfo === void 0 ? void 0 : appInfo.name) || '',
            avatar: (appInfo === null || appInfo === void 0 ? void 0 : appInfo.icon_url) ||
                getCdnUrl(cdnBaseUrlPath, 'assets/imgs/coze-logo.png'),
            id: (appInfo === null || appInfo === void 0 ? void 0 : appInfo.appId) || '',
        }, chatGroup: chatGroup, isQuery: false, messageWrapperConf: messageWrapperConf }, { children: _jsx(RespMessageListContent, { isAWaiting: isAWaiting, isShowSuggestion: isShowSuggestion, followUpMessages: followUpMessages, answerMessages: answerMessages, isLastMessage: isLastMessage }) })));
};
const RespMessageListContent = ({ answerMessages, followUpMessages, isAWaiting, isShowSuggestion, isLastMessage, }) => {
    const isNeedTextToAudio = useIsNeedTextToAudio();
    const onImageClick = useChatPropsStore(store => { var _a; return (_a = store.eventCallbacks) === null || _a === void 0 ? void 0 : _a.onImageClick; });
    const onLinkClick = useChatPropsStore(store => { var _a; return (_a = store.eventCallbacks) === null || _a === void 0 ? void 0 : _a.onLinkClick; });
    const setTaskList = useChatInputStore(store => store.setTaskList);
    const messageUiConfigMap = useChatPropsStore(store => { var _a, _b; return (_b = (_a = store.ui) === null || _a === void 0 ? void 0 : _a.chatSlot) === null || _b === void 0 ? void 0 : _b.message; });
    const i18n = useI18n();
    const themeType = useThemeType();
    const isReadOnly = useChatPropsStore(store => { var _a; return (_a = store.ui) === null || _a === void 0 ? void 0 : _a.isReadonly; });
    const { sendTextMessage } = useSendMessage();
    const onMessageTaskChange = usePersistCallback((taskInfoProps) => {
        setTaskList(taskInfoProps);
        logger.debug('RespMessageListContent Task Select', taskInfoProps);
    });
    const svgTheme = themeType === 'light' ? 'dark' : 'light';
    const allText = answerMessages
        .filter(item => item.content_type === 'text')
        .map(item => item.content)
        .join('');
    const isNeedWaitingMessage = isAWaiting && !answerMessages.some(item => !item.isComplete);
    if (isAWaiting &&
        answerMessages.length === 0 &&
        followUpMessages.length === 0) {
        return _jsx(WaitingMessage, {});
    }
    return (_jsxs(Spacing, Object.assign({ className: styles.resp, vertical: true, gap: 8 }, { children: [answerMessages.length > 0 ? (_jsxs(_Fragment, { children: [_jsx(Spacing, Object.assign({ vertical: true, className: styles.answer, gap: 8 }, { children: answerMessages.map((item, index) => (_jsx(CommandTooltip, Object.assign({ message: item, isActive: !isLastMessage && !isReadOnly }, { children: _jsx(MessageContent, { message: item, onImageClick: onImageClick, onLinkClick: onLinkClick, sendTextMessage: sendTextMessage, i18n: i18n, 
                                //disabled={!isLastMessage || isReadOnly}
                                isLastMessage: isLastMessage, isReadOnly: isReadOnly, isAWaiting: 
                                // 如果是回答的最后一条消息，同时是等待中的消息，则添加一个圆点的等待状态
                                followUpMessages.length === 0 &&
                                    answerMessages.length - 1 === index &&
                                    isAWaiting &&
                                    !item.isComplete, onTaskChange: onMessageTaskChange, messageUiConfigMap: messageUiConfigMap }) }), item.id || `noId_${index}`))) })), isLastMessage && !isAWaiting && allText ? (_jsxs(Spacing, Object.assign({ gap: 4, verticalCenter: true }, { children: [isNeedTextToAudio ? (_jsx(CommandAudio, { text: allText, svgTheme: svgTheme, isNeedHover: svgTheme === 'dark' ? true : false })) : null, _jsx(CommandCopy, { text: allText, svgTheme: svgTheme, isNeedHover: svgTheme === 'dark' ? true : false })] }))) : null] })) : null, followUpMessages.length > 0 && isShowSuggestion ? (_jsx(SuggestionList, { messages: followUpMessages })) : null, isNeedWaitingMessage ? _jsx(WaitingMessage, {}) : null] })));
};
//# sourceMappingURL=index.js.map