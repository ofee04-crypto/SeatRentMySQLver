var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { RecorderEvent, BaseRecorderManager, } from './type';
import { getWaveBlob2 } from '../webm-to-wav';
import { MiniChatError, MiniChatErrorCode } from '../mini-chat-error';
import { logger } from '../logger';
export class H5RecorderManager extends BaseRecorderManager {
    constructor() {
        super(...arguments);
        this.options = {};
        this.stream = null;
        this.tempFile = '';
        this.size = 0;
        this.duration = 0;
        this.isSendCompleted = false;
        this.inputLBuffer = [];
        this.inputRBuffer = [];
    }
    getUserMedia() {
        return new Promise((resolve, reject) => {
            const { sampleRate = 48000, numberOfChannels = 1 } = this.options;
            let isComplete = false;
            navigator.mediaDevices
                .getUserMedia({
                audio: {
                    sampleRate,
                    channelCount: numberOfChannels,
                },
            })
                .then(stream => {
                logger.debug('H5RecorderManager getUserMedia success', stream);
                if (isComplete) {
                    this.stopStream(stream);
                }
                else {
                    resolve(stream);
                }
                isComplete = true;
            })
                .catch(error => {
                isComplete = true;
                logger.debug('H5RecorderManager getUserMedia catch', error);
                reject(error);
            });
            setTimeout(() => {
                isComplete = true;
                reject(new Error('getUserMedia timeout'));
            }, 3000);
        });
    }
    start(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.options = options;
            this.options.numberOfChannels = options.numberOfChannels || 1;
            this.options.sampleRate = options.sampleRate || 48000;
            this.size = 0;
            this.inputLBuffer = [];
            this.inputRBuffer = [];
            this.stream = null;
            this.isSendCompleted = false;
            try {
                this.stream = yield this.getUserMedia();
                logger.debug('H5RecorderManager stream get success', this.isStop, this.stream);
                if (this.isStop) {
                    logger.warn("H5RecorderManager is stopped before it's started");
                    this.stopStream();
                    this.emitStop();
                    return;
                }
                this.startRecord();
            }
            catch (error) {
                logger.error('H5RecorderManager getUserMedia error', error);
                this.emitError(new MiniChatError(MiniChatErrorCode.Audio_Permission_Denied, 'getUserMedia error'));
                this.stop();
            }
        });
    }
    startRecord() {
        if (!this.stream) {
            throw new Error('stream is null');
        }
        const { numberOfChannels } = this.options;
        this.audioContext = new (window.AudioContext ||
            // @ts-expect-error -- linter-disable-autofix
            window.webkitAudioContext)();
        this.audioSource = this.audioContext.createMediaStreamSource(this.stream);
        this.analyser = this.audioContext.createAnalyser();
        this.analyser.fftSize = 128;
        const createAudioNode = this.audioContext.createScriptProcessor ||
            // @ts-expect-error -- linter-disable-autofix
            this.audioContext.createJavaScriptNode;
        const processor = createAudioNode.call(this.audioContext, 4096, numberOfChannels, numberOfChannels);
        this.processor = processor;
        this.audioSource.connect(this.analyser);
        this.audioSource.connect(processor);
        processor.connect(this.audioContext.destination);
        this._registerVolume();
        this.listenAudioProcess();
    }
    listenAudioProcess() {
        if (!this.processor) {
            throw new Error('stream is null');
        }
        this.processor.onaudioprocess = event => {
            const lData = event.inputBuffer.getChannelData(0);
            this.inputLBuffer.push(new Float32Array(lData));
            this.size += lData.length;
            if (this.options.numberOfChannels === 2) {
                const rData = event.inputBuffer.getChannelData(1);
                this.size += rData.length;
                this.inputRBuffer.push(new Float32Array(event.inputBuffer.getChannelData(1)));
            }
        };
    }
    stopMedia() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.stream || this.size === 0) {
                return;
            }
            (_a = this.audioSource) === null || _a === void 0 ? void 0 : _a.disconnect();
            (_b = this.analyser) === null || _b === void 0 ? void 0 : _b.disconnect();
            (_c = this.processor) === null || _c === void 0 ? void 0 : _c.disconnect();
            (_d = this.audioContext) === null || _d === void 0 ? void 0 : _d.close();
            this.stopStream();
            const audioBuffer = this.genAudioBuffer();
            this.duration = audioBuffer.duration * 1000;
            this.wavBlob = yield getWaveBlob2(audioBuffer, false);
            this.tempFile = URL.createObjectURL(this.wavBlob);
            this.emitStop();
        });
    }
    flat(size, inputBuffer) {
        const data = new Float32Array(size);
        // 合并
        let offset = 0;
        for (let i = 0; i < inputBuffer.length; i++) {
            data.set(inputBuffer[i], offset);
            offset += inputBuffer[i].length;
        }
        return data;
    }
    genAudioBuffer() {
        var _a;
        const audioBuffer = new AudioBuffer({
            length: this.size,
            sampleRate: ((_a = this.audioContext) === null || _a === void 0 ? void 0 : _a.sampleRate) || 48000,
            numberOfChannels: this.options.numberOfChannels || 1,
        });
        const singleSize = this.options.numberOfChannels === 2 ? this.size / 2 : this.size;
        const lData = this.flat(singleSize, this.inputLBuffer);
        audioBuffer.copyToChannel(lData, 0, 0);
        if (this.options.numberOfChannels === 2) {
            const rData = this.flat(singleSize, this.inputRBuffer);
            audioBuffer.copyToChannel(rData, 1, 0);
        }
        return audioBuffer;
    }
    _registerVolume() {
        if (!this.analyser) {
            return () => 0;
        }
        const dataArray = new Uint8Array(this.analyser.frequencyBinCount).slice(0, 64);
        const getVolume = () => {
            var _a;
            if (this.isStop) {
                this.emit(RecorderEvent.VOLUME, {
                    volume: 0,
                });
                return;
            }
            // 计算音量
            (_a = this.analyser) === null || _a === void 0 ? void 0 : _a.getByteFrequencyData(dataArray);
            let volumeSum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                volumeSum += Math.abs(dataArray[i]) * Math.abs(dataArray[i]);
            }
            const volume = volumeSum / dataArray.length / 255 / 255;
            this.emit(RecorderEvent.VOLUME, {
                volume: volume < 0.002 ? 0 : volume,
            });
            setTimeout(() => {
                getVolume();
            }, 100);
        };
        getVolume();
    }
    emitStop() {
        if (this.isSendCompleted) {
            return;
        }
        this.isSendCompleted = true;
        this.emit(RecorderEvent.STOP, {
            duration: this.duration || 0,
            tempFilePath: this.tempFile,
            fileSize: this.size,
            content: this.wavBlob,
            fileName: `recorder_${Date.now()}.wav`,
        });
    }
    emitError(error) {
        if (this.isSendCompleted) {
            return;
        }
        this.isSendCompleted = true;
        this.emit(RecorderEvent.ERROR, error);
    }
    destroy() {
        this.stop();
        this.event.off();
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isStop) {
                logger.warn('recorder has been stopped');
                return;
            }
            logger.debug('H5RecorderManager stop');
            this.isStop = true;
            try {
                yield this.stopMedia();
                this.event.off();
                this.stream = null;
                this.audioContext = undefined;
                this.audioSource = undefined;
                this.analyser = undefined;
                this.processor = undefined;
                this.wavBlob = undefined;
                this.inputLBuffer = [];
                this.inputRBuffer = [];
            }
            catch (_err) {
                this.emitError(new MiniChatError(-1, 'unknown error'));
            }
        });
    }
    stopStream(stream) {
        var _a;
        (_a = (stream || this.stream)) === null || _a === void 0 ? void 0 : _a.getTracks().forEach(track => {
            logger.debug('H5RecorderManager , stopStream', track);
            track.stop();
        });
    }
    pause() {
        if (this.isStop) {
            logger.error('recorder has been stopped');
            return;
        }
    }
    resume() {
        if (this.isStop) {
            logger.error('recorder has been stopped');
            return;
        }
    }
}
export class H5RecorderManagerInstance extends H5RecorderManager {
    start(options) {
        const _super = Object.create(null, {
            start: { get: () => super.start }
        });
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isStop) {
                throw new MiniChatError(-1, 'recorder is stop');
            }
            logger.debug('H5RedorManagerInstance start instance stopFlag', (_a = H5RecorderManagerInstance.curInstance) === null || _a === void 0 ? void 0 : _a.isStop);
            // There's only one instance at a time.
            if (!((_b = H5RecorderManagerInstance.curInstance) === null || _b === void 0 ? void 0 : _b.isStop)) {
                (_c = H5RecorderManagerInstance.curInstance) === null || _c === void 0 ? void 0 : _c.stop();
            }
            H5RecorderManagerInstance.curInstance = this;
            return yield _super.start.call(this, options);
        });
    }
}
//# sourceMappingURL=h5-recorder-manager.js.map