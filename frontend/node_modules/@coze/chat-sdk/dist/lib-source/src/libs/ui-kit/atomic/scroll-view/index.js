var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, memo, useImperativeHandle, useLayoutEffect, useMemo, useRef, } from 'react';
import cls from 'classnames';
import { ScrollView as TaroScrollView, View, } from '@tarojs/components';
import { isWeb, logger } from "../../../utils";
import { usePersistCallback } from "../../../hooks";
import { SvgArrowUp } from '../svg';
import { IconButton } from '../icon-button';
import { useScrollTop } from './use-scroll-top';
import { useScrollHandle } from './use-scroll-handle';
import { useSafariAnchorHack } from './use-safari-anchor-hack';
import { useHelperButton } from './use-helper-button';
import styles from './index.module.less';
const TaroScrollViewMemo = memo(TaroScrollView);
const ScrollViewSlot = memo(forwardRef((_a, ref) => {
    var { id, children, isLoadMore, checkArrowDownVisible, lowerThreshold: lowerThresholdRaw, onScrollToLower } = _a, restProps = __rest(_a, ["id", "children", "isLoadMore", "checkArrowDownVisible", "lowerThreshold", "onScrollToLower"]);
    const { scrollTop, delayToSetScroll, scrollToAnchorBottom, onInitScrollEl, refScrollEl, } = useScrollTop();
    const refAnchorBottom = useRef(false);
    const { onInitViewEl, onCollectScrollInfo } = useSafariAnchorHack({
        refAnchorBottom,
        refScrollEl,
    });
    const reCheckToLower = usePersistCallback(() => {
        if (refScrollNow.current > 100) {
            delayToSetScroll(refScrollNow.current - 0.5);
        }
    });
    const { refScrollNow, onScrollToLowerHandle, lowerThreshold, onScrollHandle, } = useScrollHandle({
        refScrollEl,
        scrollToAnchorBottom,
        onCollectScrollInfoInSafari: onCollectScrollInfo,
        checkArrowDownVisible,
        onScrollToLower,
        lowerThreshold: lowerThresholdRaw,
        reCheckToLower,
    });
    useLayoutEffect(() => {
        if (isLoadMore) {
            delayToSetScroll(refScrollNow.current + 2);
        }
    }, [isLoadMore]);
    useImperativeHandle(ref, () => ({
        scrollToBottom: () => {
            logger.debug('ScrollView, scrollToBottom', { scrollTop });
            scrollToAnchorBottom();
        },
        scrollToAnchorBottom: () => {
            // 如果重复设置0的话，不会生效，因此如果是0的时候，需要先设置1，然后再设置锚定位置0
            logger.debug('ScrollView, scrollToAnchorBottom', { scrollTop });
            refAnchorBottom.current = true;
            scrollToAnchorBottom();
        },
        removeAnchorBottom: () => {
            logger.debug('ScrollView, removeAnchorBottom', {
                currentTop: refScrollNow.current,
                scrollTop,
            });
            refAnchorBottom.current = false;
            if (refScrollNow.current === 0 && scrollTop === 0) {
                // 防止内容未渲染完成，已经完成了修改，导致新内容未能锚定底部，预防措施
                delayToSetScroll(1, 50);
            }
        },
    }), [scrollTop]);
    const chatScrollContent = useMemo(() => (
    // 防止  scrollView 重新渲染，导致重新设置scrollTop。
    _jsx(View, Object.assign({ className: cls(styles.children), ref: onInitViewEl }, { children: children }))), [children]);
    return (_jsx(TaroScrollViewMemo, Object.assign({}, restProps, { id: id, ref: onInitScrollEl, scrollTop: scrollTop, lowerThreshold: lowerThreshold, onScrollToLower: onScrollToLowerHandle, reverse: false, showScrollbar: false, enhanced: true, className: cls(styles.scroll, {
            [styles['scroll-web']]: isWeb,
        }), onScroll: onScrollHandle }, { children: chatScrollContent })));
}));
export const ScrollView = forwardRef((_a, ref) => {
    var { className, isNeedHelper, children } = _a, restProps = __rest(_a, ["className", "isNeedHelper", "children"]);
    const { arrowDownVisible, checkArrowDownVisible, setArrowDownVisible } = useHelperButton(isNeedHelper);
    const refScroll = useRef(null);
    useImperativeHandle(ref, () => ({
        scrollToBottom: () => {
            var _a;
            (_a = refScroll.current) === null || _a === void 0 ? void 0 : _a.scrollToBottom();
        },
        scrollToAnchorBottom: () => {
            var _a;
            (_a = refScroll.current) === null || _a === void 0 ? void 0 : _a.scrollToAnchorBottom();
        },
        removeAnchorBottom: () => {
            var _a;
            (_a = refScroll.current) === null || _a === void 0 ? void 0 : _a.removeAnchorBottom();
        },
    }), []);
    return (_jsxs(View, Object.assign({ className: cls(styles.container, className) }, { children: [_jsx(ScrollViewSlot, Object.assign({}, restProps, { checkArrowDownVisible: checkArrowDownVisible, ref: refScroll }, { children: children })), _jsx(IconButton, Object.assign({ type: "circle-btn", size: "large", className: cls(styles['arrow-down'], {
                    [styles['arrow-down--show']]: arrowDownVisible,
                }), onClick: () => {
                    var _a;
                    logger.debug('ScrollView, arrowDownVisible, onClick', refScroll.current);
                    if (refScroll.current) {
                        (_a = refScroll === null || refScroll === void 0 ? void 0 : refScroll.current) === null || _a === void 0 ? void 0 : _a.scrollToBottom();
                        setArrowDownVisible(false);
                    }
                } }, { children: _jsx(SvgArrowUp, {}) }))] })));
});
//# sourceMappingURL=index.js.map