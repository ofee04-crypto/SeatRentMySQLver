import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useEffect, useMemo, useState } from 'react';
import cls from 'classnames';
import { isBoolean } from '@tarojs/shared';
import { Text, View } from '@tarojs/components';
import { Spacing } from "../../../../spacing";
import { Radio } from "../../../../radio";
import { Checkbox } from "../../../../check-box";
import { CenterAlignedBox } from "../../../../center-aligned-box";
import { usePersistCallback } from "../../../../../../hooks";
import { ListItem } from '../list-item';
import { getTextFromParagraph } from '../../../helper/get-text-from-paragraph';
import { useMdStreamLogger, useMdStreamTaskChangeHandle, useMdStreamTaskDisabled, } from '../../../context';
import styles from './index.module.less';
let listNo = 1000;
export const List = ({ node }) => {
    const listNoId = useMemo(() => listNo++, []);
    const formatItems = useFormatNodeChildren(node, listNoId);
    const logger = useMdStreamLogger();
    const taskDisabled = useMdStreamTaskDisabled();
    const onTaskChangeHandle = useMdStreamTaskChangeHandle();
    const [listItems, setListItems] = useState([]);
    useEffect(() => {
        setListItems(formatItems);
    }, [formatItems]);
    const onTaskChange = usePersistCallback((isChecked, taskInfo) => {
        listItems.map(item => {
            if (isChecked) {
                if (taskInfo.radio) {
                    // If the changed task is radio,then set property 'checked'  false;
                    if (item.taskInfo.radio) {
                        item.taskInfo.checked = false;
                    }
                }
            }
            if (taskInfo.id === item.taskInfo.id) {
                item.taskInfo.checked = isChecked;
            }
        });
        setListItems([...listItems]);
    });
    useEffect(() => {
        const isTaskList = listItems.some(item => item.isTask);
        if (isTaskList && !taskDisabled) {
            const values = listItems
                .map(item => {
                if (item.taskInfo.checked && item.taskInfo.value) {
                    return item.taskInfo.value;
                }
                return '';
            })
                .filter(item => !!item);
            onTaskChangeHandle === null || onTaskChangeHandle === void 0 ? void 0 : onTaskChangeHandle({
                id: `task_list_${listNoId}`,
                index: listNoId,
                values,
            });
            logger === null || logger === void 0 ? void 0 : logger.debug('taskChange:', values, listNoId);
        }
    }, [listItems, taskDisabled]);
    return (_jsx(View, Object.assign({ className: styles.list }, { children: listItems.map((item, index) => (_jsx(ListItemWrapper, Object.assign({ listItemInfo: item, onChange: onTaskChange }, { children: _jsx(View, Object.assign({ className: styles.content }, { children: _jsx(ListItem, { node: item.node }) })) }), index))) })));
};
const ListItemWrapper = ({ listItemInfo, children, onChange }) => (_jsx(_Fragment, { children: listItemInfo.isTask ? (_jsx(ListTaskWrapper, Object.assign({ nodeInfo: listItemInfo, onChange: onChange }, { children: children }))) : (_jsxs(Spacing, Object.assign({ className: cls(styles['list-item'], {
            [styles['order-list']]: listItemInfo.isOrder,
        }), gap: 6, width100: true }, { children: [_jsx(CenterAlignedBox, Object.assign({ width: 21, height: 22 }, { children: listItemInfo.isOrder ? (_jsxs(Text, { children: [listItemInfo.orderNo, "."] })) : (_jsx(View, { className: styles.dot })) })), _jsx(View, Object.assign({ style: {
                    flex: 1,
                    overflow: 'hidden',
                } }, { children: children }))] }))) }));
const ListTaskWrapper = ({ nodeInfo, children, onChange }) => {
    const onChangeHandle = usePersistCallback((isChecked) => {
        onChange === null || onChange === void 0 ? void 0 : onChange(isChecked, nodeInfo.taskInfo);
    });
    const taskDisabled = useMdStreamTaskDisabled();
    return (_jsx(_Fragment, { children: nodeInfo.taskInfo.radio ? (_jsx(Radio, Object.assign({ checked: nodeInfo.taskInfo.checked, className: styles['task-item'], onChange: onChangeHandle, disabled: taskDisabled }, { children: children }))) : (_jsx(Checkbox, Object.assign({ checked: nodeInfo.taskInfo.checked, className: styles['task-item'], onChange: onChangeHandle, disabled: taskDisabled }, { children: children }))) }));
};
const useFormatNodeChildren = (node, listNoId) => {
    let isForbidChecked = false;
    const nodeChildren = useMemo(() => node.children.map((item, index) => {
        var _a;
        const listItemData = (item.data || {});
        const selectData = {
            id: `list_prefix_${listNoId}_${index}`,
            checkbox: isBoolean(item.checked),
            radio: !!listItemData.radio,
            checked: (_a = item.checked) !== null && _a !== void 0 ? _a : listItemData.checked,
            value: '',
        };
        const isTask = !!(selectData.checkbox || selectData.radio);
        selectData.value = isTask
            ? (() => {
                var _a, _b;
                // We just extract text from first paragraph.This is already agreed upon in advance
                if (((_a = item.children) === null || _a === void 0 ? void 0 : _a[0].type) === 'paragraph') {
                    return getTextFromParagraph((_b = item.children) === null || _b === void 0 ? void 0 : _b[0]);
                }
                else {
                    return '';
                }
            })()
            : '';
        // Radio component only the first can be set to "checked"
        if (selectData.radio && selectData.checked) {
            if (isForbidChecked) {
                selectData.checked = false;
            }
            isForbidChecked = true;
        }
        return {
            isTask,
            node: item,
            isOrder: !!node.ordered,
            orderNo: index + 1,
            taskInfo: selectData,
        };
    }), [node]);
    return nodeChildren;
};
//# sourceMappingURL=index.js.map