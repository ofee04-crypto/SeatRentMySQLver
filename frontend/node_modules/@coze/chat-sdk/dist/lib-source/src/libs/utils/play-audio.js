var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import Taro, { Events } from '@tarojs/taro';
import { MiniChatError } from './mini-chat-error';
import { logger } from './logger';
import { isWeb } from './device';
export var AudioPlayEvent;
(function (AudioPlayEvent) {
    AudioPlayEvent["STOP"] = "stop";
    AudioPlayEvent["PLAY"] = "play";
})(AudioPlayEvent || (AudioPlayEvent = {}));
let playNo = 1000;
export class PlayAudio {
    constructor() {
        this.isStop = true;
        this.event = new Events();
        this.audioPrm = null;
        this.filePath = '';
    }
    static stopNow() {
        var _a;
        (_a = PlayAudio.instance) === null || _a === void 0 ? void 0 : _a.stop();
    }
    playText(text, audioSpeechFunc) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = PlayAudio.instance) === null || _a === void 0 ? void 0 : _a.isStop)) {
                (_b = PlayAudio.instance) === null || _b === void 0 ? void 0 : _b.stop();
            }
            if (!this.audioPrm) {
                this.audioPrm = audioSpeechFunc(text);
            }
            this.isStop = false;
            PlayAudio.instance = this;
            try {
                const audioData = yield this.audioPrm;
                if (this.isStop) {
                    return;
                }
                this.playData(audioData);
            }
            catch (e) {
                this.audioPrm = null;
                logger.error('PlayAudio Get audio speech error', e);
                throw new MiniChatError(-1, 'Get Speech Failed');
            }
        });
    }
    playData(data) {
        let tempFile = '';
        if (isWeb) {
            const blobData = new Blob([data], {
                type: 'audio/wav',
            });
            tempFile = URL.createObjectURL(blobData);
        }
        else {
            tempFile = `${Taro.env.USER_DATA_PATH}/tempFile${playNo++}.wav`;
            this.filePath = tempFile;
            Taro.getFileSystemManager().writeFileSync(tempFile, data, 'binary');
        }
        logger.debug('playData:', tempFile);
        this.play(tempFile);
    }
    play(audioSrc) {
        return __awaiter(this, void 0, void 0, function* () {
            PlayAudio.instance = this;
            this.audioContext = Taro.createInnerAudioContext();
            this.audioContext.src = audioSrc;
            if (!isWeb) {
                this.audioContext.obeyMuteSwitch = false;
            }
            logger.debug('audioContext', audioSrc);
            this.audioContext.onPlay(() => {
                logger.debug('audioContext onPlay');
                this.event.trigger(AudioPlayEvent.PLAY);
            });
            this.audioContext.onPause(() => {
                this.stop();
            });
            this.audioContext.onError(res => {
                logger.error('audioContext onError', res);
                this.emitStopEvent(true);
                this.stop();
            });
            this.audioContext.onEnded(() => {
                logger.debug('audioContext onEnded');
                this.stop();
            });
            this.audioContext.onStop(() => {
                this.unregister();
                logger.debug('audioContext onStop');
            });
            try {
                yield this.audioContext.play();
            }
            catch (err) {
                logger.error('audioContext play error', err);
            }
            logger.debug('audioContext', audioSrc);
        });
    }
    stop() {
        var _a;
        logger.debug('audioContext stop1', this.isStop);
        if (this.isStop) {
            return;
        }
        try {
            this.emitStopEvent();
            (_a = this.audioContext) === null || _a === void 0 ? void 0 : _a.stop();
            this.unregister();
            this.isStop = true;
        }
        catch (_err) {
            this.emitStopEvent(true);
        }
        this.removeAudio();
    }
    removeAudio() {
        try {
            if (!isWeb) {
                Taro.getFileSystemManager().unlinkSync(this.filePath || '');
            }
        }
        catch (err) {
            logger.error('removeAudio error', err);
        }
    }
    on(event, callback) {
        this.event.on(event, callback);
    }
    emitStopEvent(isError = false) {
        logger.debug('audioContext emitStopEvent', this.isStop);
        if (this.isStop) {
            return;
        }
        this.event.trigger(AudioPlayEvent.STOP, {
            isError,
        });
    }
    unregister() {
        var _a, _b, _c, _d;
        (_a = this.audioContext) === null || _a === void 0 ? void 0 : _a.offPlay();
        (_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.offError();
        (_c = this.audioContext) === null || _c === void 0 ? void 0 : _c.offEnded();
        (_d = this.audioContext) === null || _d === void 0 ? void 0 : _d.offPause();
        this.event.off();
    }
}
//# sourceMappingURL=play-audio.js.map