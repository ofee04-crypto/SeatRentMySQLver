var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { useEffect, useRef, useState } from 'react';
import { getBoundingRect, isWeb, logger } from "../../../utils";
import { UIEventType } from "../../../types";
import { usePersistCallback, useUpdateEffect } from "../../../hooks";
// eslint-disable-next-line max-lines-per-function
export const useAudioRecord = ({ onTouching, onOutside, onEnd, frameEventTarget, isPcMode, disabled, }) => {
    const refAudioInput = useRef(null);
    const [isTouching, setIsTouching] = useState(false);
    const [isOutside, setIsOutside] = useState(false);
    const refAudioInputBounding = useRef();
    const triggerFromRef = useRef();
    const onOutsideChange = usePersistCallback((isOutsideNew) => {
        setIsOutside(isOutsideNew);
        onOutside === null || onOutside === void 0 ? void 0 : onOutside(isOutsideNew);
    });
    const onStartAudioInput = usePersistCallback((event) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        setIsTouching(true);
        setIsOutside(false);
        if (isWeb) {
            const boundingRect = (_a = refAudioInput.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
            if (boundingRect) {
                refAudioInputBounding.current = boundingRect;
            }
        }
        else if (event) {
            const [boundingRect] = yield getBoundingRect(`#${event.currentTarget.id}`);
            if (boundingRect) {
                refAudioInputBounding.current = boundingRect;
            }
        }
    }));
    const checkIsOutside = usePersistCallback((event) => {
        const { clientY } = event;
        const { top } = refAudioInputBounding.current || {};
        let isOutsideNew = false;
        if (top !== undefined && clientY < top) {
            isOutsideNew = true;
        }
        return isOutsideNew;
    });
    const checkAndSetIsOutside = usePersistCallback((event) => {
        const isOutsideNew = checkIsOutside(event);
        onOutsideChange(isOutsideNew);
        return isOutsideNew;
    });
    /** Start Mouse Event Handler On Mobile */
    const onTouchStart = usePersistCallback((event) => {
        logger.debug('[useAudioRecord]onTouchStart', event);
        if (triggerFromRef.current || disabled) {
            return;
        }
        triggerFromRef.current = 'touch';
        onStartAudioInput(event);
    });
    const onTouchMove = usePersistCallback((event) => {
        logger.debug('[useAudioRecord]onTouchMove', event);
        if (triggerFromRef.current !== 'touch' || disabled) {
            return;
        }
        if (isTouching) {
            checkAndSetIsOutside({
                clientX: event.changedTouches[0].clientX,
                clientY: event.changedTouches[0].clientY,
            });
        }
    });
    const onTouchEnd = usePersistCallback(() => {
        logger.debug('[useAudioRecord]onTouchEnd', triggerFromRef.current, isTouching);
        if (triggerFromRef.current !== 'touch' || disabled) {
            return;
        }
        if (isTouching) {
            setIsTouching(false);
        }
    });
    const onTouchCancel = usePersistCallback((event) => {
        logger.debug('[useAudioRecord]onTouchCancel', event);
        setIsTouching(false);
        setIsOutside(false);
    });
    /** End Mouse Event Handler On Mobile */
    /** Start Mouse Event Handler On Pc */
    const onMouseDown = usePersistCallback((event) => {
        logger.debug('onMouseDown', event);
        event === null || event === void 0 ? void 0 : event.stopPropagation();
        if (triggerFromRef.current || disabled) {
            return;
        }
        triggerFromRef.current = 'mouse';
        onStartAudioInput();
    });
    const onMouseMove = usePersistCallback((event) => {
        if (triggerFromRef.current !== 'mouse' || disabled) {
            return;
        }
        if (isTouching) {
            checkAndSetIsOutside({
                clientX: event.clientX,
                clientY: event.clientY,
            });
        }
    });
    const onMouseUp = usePersistCallback((event) => {
        logger.info('onMouseDown 222', event, isTouching);
        if (triggerFromRef.current !== 'mouse' || disabled) {
            return;
        }
        if (isTouching) {
            setIsTouching(false);
        }
    });
    const onKeyDown = usePersistCallback((event) => {
        logger.debug('[audio] onKeyDown', event);
        if (event.code === 'Space') {
            if (triggerFromRef.current || disabled) {
                return;
            }
            triggerFromRef.current = 'keyboard';
            setIsTouching(true);
            setIsOutside(false);
        }
    });
    const onKeyUp = usePersistCallback((event) => {
        logger.debug('[audio] onKeyUp', event);
        if (disabled) {
            return;
        }
        if (event.code === 'Space') {
            if (triggerFromRef.current !== 'keyboard') {
                return;
            }
            if (isTouching) {
                setIsTouching(false);
            }
        }
    });
    const onInitRefForAudioRecord = usePersistCallback(el => {
        if (isWeb) {
            // If the element has been set, remove the event listener first
            if (refAudioInput.current) {
                refAudioInput.current.removeEventListener('mousedown', onMouseDown);
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                if (isPcMode && frameEventTarget) {
                    frameEventTarget.on(UIEventType.KeyDown, onKeyDown);
                    frameEventTarget.on(UIEventType.KeyUp, onKeyUp);
                }
            }
            // Set the new element, and add the event listener
            if (el) {
                refAudioInput.current = el;
                refAudioInput.current.addEventListener('mousedown', onMouseDown);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                if (isPcMode && frameEventTarget) {
                    frameEventTarget.on(UIEventType.KeyDown, onKeyDown);
                    frameEventTarget.on(UIEventType.KeyUp, onKeyUp);
                }
            }
        }
        else {
            refAudioInput.current = el;
        }
    });
    useEffect(() => () => {
        var _a;
        if (isWeb) {
            (_a = refAudioInput.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('mousedown', onMouseDown);
            document === null || document === void 0 ? void 0 : document.removeEventListener('mousemove', onMouseMove);
            document === null || document === void 0 ? void 0 : document.removeEventListener('mouseup', onMouseUp);
            if (frameEventTarget) {
                frameEventTarget.off(UIEventType.KeyDown, onKeyDown);
                frameEventTarget.off(UIEventType.KeyDown, onKeyUp);
            }
        }
    }, []);
    /** End Mouse Event Handler On Pc */
    useUpdateEffect(() => {
        logger.debug('[useAudioRecord]isTouching', isTouching);
        if (isTouching) {
            onTouching === null || onTouching === void 0 ? void 0 : onTouching(triggerFromRef.current);
        }
    }, [isTouching]);
    useUpdateEffect(() => {
        onOutside === null || onOutside === void 0 ? void 0 : onOutside(isOutside);
    }, [isOutside]);
    useUpdateEffect(() => {
        logger.info('[useAudioRecord]onEnd', isTouching);
        if (!isTouching) {
            triggerFromRef.current = undefined;
            onEnd === null || onEnd === void 0 ? void 0 : onEnd();
        }
    }, [isTouching]);
    useUpdateEffect(() => {
        if (isTouching) {
            setIsTouching(false);
        }
        /*if (isOutside) {
          setIsOutside(false);
        }*/
    }, [disabled]);
    return {
        onInitRefForAudioRecord,
        onTouchStart,
        onTouchMove,
        onTouchEnd,
        onTouchCancel,
        isTouching,
        isOutside,
    };
};
//# sourceMappingURL=use-audio-record.js.map