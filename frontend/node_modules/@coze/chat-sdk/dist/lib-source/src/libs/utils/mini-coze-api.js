var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
import axios from 'axios';
import Taro from '@tarojs/taro';
import { CozeAPI, } from '@coze/api';
import { safeJSONParse } from './safe-json-parse';
import { convertToMinChatError, MiniChatError } from './mini-chat-error';
import { logger } from './logger';
import { requestSSE } from './event-source/request';
import { EventJsonDataType } from './event-source/event-source';
import { isTT, isWeb } from './device';
import { taroAdapter } from './adapter';
var ApiAuthError;
(function (ApiAuthError) {
    ApiAuthError[ApiAuthError["ERROR_FORBIDDEN"] = 401] = "ERROR_FORBIDDEN";
    ApiAuthError[ApiAuthError["ERROR_INVALID_TOKEN"] = 4100] = "ERROR_INVALID_TOKEN";
    ApiAuthError[ApiAuthError["ERROR_TOKEN_FORBIDDEN"] = 4101] = "ERROR_TOKEN_FORBIDDEN";
    ApiAuthError[ApiAuthError["ERROR_TOKEN_FAILED"] = 700012006] = "ERROR_TOKEN_FAILED";
})(ApiAuthError || (ApiAuthError = {}));
export class MiniCozeApi2 extends CozeAPI {
}
export class MiniCozeApi extends CozeAPI {
    constructor(_a) {
        var { onRefreshToken, axiosOptions } = _a, config = __rest(_a, ["onRefreshToken", "axiosOptions"]);
        super(Object.assign(Object.assign({}, config), { axiosOptions: Object.assign(Object.assign({}, (axiosOptions || {})), { timeout: 10 * 60 * 1000, validateStatus: () => true }) }));
        this.onRefreshToken = onRefreshToken;
        this.axiosInstance = axios.create({
            adapter: !isWeb ? taroAdapter : undefined,
        });
        this.useAuthError();
        this.mixTaroUpload();
    }
    useAuthError() {
        this.useResponseInterceptors((response) => __awaiter(this, void 0, void 0, function* () {
            const { code } = (response === null || response === void 0 ? void 0 : response.data) || {};
            if (this.isAuthErrorCode(code || response.status)) {
                // 由于 鉴权问题导致的失败，进行一次重新发送数据。
                logger.error('request auth error :', code || response.status);
                const oldToken = this.getTokenFromHeaderAuth(String(response.config.headers.getAuthorization() || ''));
                const token = yield this.refreshToken(oldToken);
                if (token) {
                    response.config.headers.Authorization = `Bearer ${token}`;
                    return yield axios.request(response.config);
                }
            }
            if (response.status < 200 || response.status > 400) {
                logger.error('request error:', response);
                throw new Error(response.statusText);
            }
            return response;
        }), (response) => __awaiter(this, void 0, void 0, function* () {
            const { code } = (response === null || response === void 0 ? void 0 : response.data) || {};
            if (this.isAuthErrorCode(code || response.status)) {
                // 由于 鉴权问题导致的失败，进行一次重新发送数据。
                const oldToken = this.getTokenFromHeaderAuth(String(response.config.headers.getAuthorization() || ''));
                const token = yield this.refreshToken(oldToken);
                if (token) {
                    response.config.headers.Authorization = `Bearer ${token}`;
                    return yield axios.request(response.config);
                }
            }
            return response;
        }));
    }
    isAuthErrorCode(code) {
        return [
            ApiAuthError.ERROR_FORBIDDEN,
            ApiAuthError.ERROR_INVALID_TOKEN,
            ApiAuthError.ERROR_TOKEN_FORBIDDEN,
            ApiAuthError.ERROR_TOKEN_FAILED,
        ].includes(code);
    }
    getTokenFromHeaderAuth(authorization) {
        return authorization.replace(/^\s*Bearer\s*/, '').replace(/\s+$/, '');
    }
    refreshToken(oldToken) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.refreshTokenPromise) {
                return this.refreshTokenPromise;
            }
            if (oldToken !== this.token) {
                // 同时并发的接口已经获取过token，直接返回
                return this.token;
            }
            this.refreshTokenPromise = (_a = this.onRefreshToken) === null || _a === void 0 ? void 0 : _a.call(this, this.token);
            const token = yield this.refreshTokenPromise;
            this.refreshTokenPromise = undefined;
            this.token = token || '';
            return this.token;
        });
    }
    useResponseInterceptors(responseInterceptor, rejectResponseInterceptor) {
        this.getAxiosInstance().interceptors.response.use(responseInterceptor, rejectResponseInterceptor);
    }
    useRequestInterceptors(requestInterceptor) {
        this.getAxiosInstance().interceptors.request.use(requestInterceptor);
    }
    getAxiosInstance() {
        return this.axiosInstance;
    }
    // eslint-disable-next-line max-params
    makeRequest(apiUrl, method, body, isStream, options) {
        if (isWeb || !isStream) {
            try {
                return super.makeRequest(apiUrl, method, body, isStream, options);
            }
            catch (err) {
                logger.error('makeRequestError:', err);
            }
        }
        return this.requestMiniSse({
            apiUrl,
            method,
            body,
            options,
        });
    }
    // eslint-disable-next-line complexity
    requestMiniSse({ apiUrl, method, body, options, retryNum = 0, }) {
        var _a, _b;
        return __asyncGenerator(this, arguments, function* requestMiniSse_1() {
            var _c, e_1, _d, _e;
            // request intercptions处理
            const refreshTokenAndRetry = (code = -1, msg = 'unknown error') => __awaiter(this, void 0, void 0, function* () {
                if (retryNum === 0) {
                    yield this.refreshToken(oldToken);
                    return this.requestMiniSse({
                        apiUrl,
                        method,
                        body,
                        options,
                        retryNum: retryNum + 1,
                    });
                }
                else {
                    throw new MiniChatError(code, msg);
                }
            });
            const oldToken = this.token;
            const url = `${(_a = this.baseURL) !== null && _a !== void 0 ? _a : ''}/${apiUrl}`;
            const res = requestSSE(Object.assign({ url,
                method, data: body, header: Object.assign(Object.assign(Object.assign({}, (((_b = this.axiosOptions) === null || _b === void 0 ? void 0 : _b.headers) || {})), ((options === null || options === void 0 ? void 0 : options.headers) || {})), { Authorization: `Bearer ${this.token}` }) }, (options || {})));
            let eventDataNum = 0;
            try {
                for (var _f = true, res_1 = __asyncValues(res), res_1_1; res_1_1 = yield __await(res_1.next()), _c = res_1_1.done, !_c;) {
                    _e = res_1_1.value;
                    _f = false;
                    try {
                        const eventData = _e;
                        if ((eventData === null || eventData === void 0 ? void 0 : eventData.event) === EventJsonDataType) {
                            const { code = -1, msg = 'unknown error' } = (eventData.data || {});
                            if (this.isAuthErrorCode(code)) {
                                return yield __await(yield __await(refreshTokenAndRetry(code, msg)));
                            }
                            throw new MiniChatError(code || 0, msg);
                        }
                        if (eventData) {
                            eventDataNum++;
                            yield yield __await(eventData);
                        }
                    }
                    finally {
                        _f = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_f && !_c && (_d = res_1.return)) yield __await(_d.call(res_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (eventDataNum === 0) {
                if (isTT) {
                    // 无法分辨是否token过期了， 直接重试
                    return yield __await(yield __await(refreshTokenAndRetry()));
                }
                else {
                    throw new MiniChatError(-1, 'unknown error');
                }
            }
        });
    }
    mixTaroUpload() {
        if (!isWeb) {
            this.files.upload = (params, options) => this._uploadFile({
                params,
                options,
                urlPath: '/v1/files/upload',
            });
        }
        // @ts-expect-error -- linter-disable-autofix
        this.audio.transcriptions = (params, options) => {
            logger.debug('translation params', params);
            return this._uploadFile({
                params,
                options,
                urlPath: '/v1/audio/transcriptions',
            });
        };
    }
    // eslint-disable-next-line complexity
    _uploadFile({ params, options, retryNum = 0, urlPath, }) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${(_a = this.baseURL) !== null && _a !== void 0 ? _a : ''}${urlPath}`;
            const oldToken = this.token;
            try {
                const rawResult = yield Taro.uploadFile({
                    url,
                    filePath: params.file.filePath,
                    name: 'file',
                    fileName: params.file.fileName,
                    withCredentials: false,
                    header: Object.assign(Object.assign(Object.assign({}, (((_b = this.axiosOptions) === null || _b === void 0 ? void 0 : _b.headers) || {})), ((options === null || options === void 0 ? void 0 : options.headers) || {})), { Authorization: `Bearer ${this.token}` }),
                    timeout: options === null || options === void 0 ? void 0 : options.timeout,
                });
                const { code = -1, data } = safeJSONParse(rawResult.data) || {
                    code: -1,
                };
                logger.debug('_uploadFile:', { code, data });
                if (code !== 0 || !data) {
                    if (this.isAuthErrorCode(code || rawResult.statusCode) &&
                        retryNum !== 0) {
                        // 需要重试
                        yield this.refreshToken(oldToken);
                        return yield this._uploadFile({
                            params,
                            options,
                            retryNum: retryNum + 1,
                            urlPath,
                        });
                    }
                    throw new MiniChatError(code || -1, 'upload file failed');
                }
                return data;
            }
            catch (error) {
                const miniChatError = convertToMinChatError(error);
                logger.error('upload file error', error);
                throw miniChatError;
            }
        });
    }
}
//# sourceMappingURL=mini-coze-api.js.map