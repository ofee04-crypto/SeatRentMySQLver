import { Events } from '@tarojs/taro';
import { RoleType, } from '@coze/api';
import { MiniChatError, logger, nanoid } from "../../../../utils";
import { SendMessageEvent, } from "../../../../types";
export class RawSendMessage {
    constructor({ conversationId, botId, chatService, userId, connectorId, sectionId, chatInfo, i18n, }) {
        this.botId = botId;
        this.conversationId = conversationId;
        this.chatInfo = chatInfo;
        this.isAbort = false;
        this.chatService = chatService;
        this.event = new Events();
        this.messageList = [];
        this.userId = userId;
        this.chatId = '';
        this.connectorId = connectorId;
        this.sectionId = sectionId;
        this.i18n = i18n;
        //默认值，初始化使用
        this.messageSended = {
            id: '',
            role: RoleType.User,
            conversation_id: this.conversationId,
            section_id: this.sectionId,
            bot_id: this.botId,
            chat_id: '',
            localId: nanoid(),
            meta_data: {},
            content: '',
            content_type: 'text',
            created_at: Date.now(),
            updated_at: Date.now(),
            type: 'question',
        };
    }
    sendMessage(_message, _historyMessages) {
        throw new Error('Un implement sendMessage');
    }
    createAnswerTextMessage(message) {
        return {
            id: '',
            role: RoleType.User,
            conversation_id: this.conversationId,
            section_id: this.sectionId,
            bot_id: this.botId,
            chat_id: this.messageSended.chat_id,
            localId: nanoid(),
            meta_data: {},
            content: message,
            content_type: 'text',
            created_at: Date.now(),
            updated_at: Date.now(),
            type: 'answer',
        };
    }
    on(eventName, callback) {
        this.event.on(eventName, callback);
    }
    off(eventName, callback) {
        this.event.off(eventName, callback);
    }
    emit(eventName, data) {
        if (eventName === SendMessageEvent.ReceiveComplete) {
            // 调用结束，关闭对话
            this.close(data);
        }
        else {
            this.event.trigger(eventName, data);
        }
    }
    // 结束的时候，一定要调用该位置。
    close(data) {
        this._clearTimeout();
        if (this.isAbort) {
            return false;
        }
        // 关闭轮询
        const eventData = data || {
            messages: this.messageList,
            status: 'complete',
        };
        this.isAbort = true;
        this.event.trigger(SendMessageEvent.ReceiveComplete, eventData);
        this.event.trigger(SendMessageEvent.Close, eventData);
        this.event.off();
        return true;
    }
    break() {
        this.close();
        // 取消后续的模型回答，并关闭轮询
        // todo: 暂时无此场景，不处理
    }
    // question消息发送成功事件
    sendStartMessage(message) {
        this.packMessage(message);
        this.sendProcessEvent();
    }
    packMessage(message) {
        this.messageSended = Object.assign(Object.assign({}, this.messageSended), {
            content: message.content,
            content_type: message.content_type,
            // @ts-expect-error -- linter-disable-autofix
            isAudioTranslatingToText: message.isAudioTranslatingToText,
        });
        this.messageList = [this.messageSended];
    }
    // 消息打断事件，暂时未使用
    sendBreakEvent() {
        this.emit(SendMessageEvent.ReceiveComplete, {
            status: 'break',
            messages: this.messageList,
        });
    }
    // 消息进行中事件，
    sendProcessEvent() {
        logger.debug('[dev] in_process', this.messageList[this.messageList.length - 1].content);
        this.emit(SendMessageEvent.ReceiveMessage, {
            status: 'in_process',
            messages: this.messageList,
        });
    }
    sendRequireActionEvent(event) {
        this.emit(SendMessageEvent.RequireAction, {
            status: 'action',
            messages: this.messageList,
            event,
        });
    }
    // 消息完成事件
    sendCompleteEvent() {
        this.emit(SendMessageEvent.ReceiveComplete, {
            status: 'complete',
            messages: this.messageList,
        });
    }
    // 消息失败事件
    sendErrorEvent(error = new MiniChatError(-1, '对话失败')) {
        this.emit(SendMessageEvent.ReceiveComplete, {
            status: 'error',
            messages: this.messageList,
            error,
        });
    }
    _checkTimeout(timeout = 210000) {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
        }
        this.timeoutId = setTimeout(() => {
            logger.error('send message timeout');
            this.sendErrorEvent(new MiniChatError(-1, 'timeout'));
        }, timeout);
    }
    _clearTimeout() {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
        }
    }
}
//# sourceMappingURL=raw-send-message.js.map