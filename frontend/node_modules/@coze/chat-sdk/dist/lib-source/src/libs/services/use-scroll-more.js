var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { useCallback, useRef } from 'react';
import { useApiClientStore } from "../provider";
import { logger } from '../utils';
import { useConversationStore } from '../provider/context/chat-store-context';
const UPPER_THRESHOLD = 100;
export const useScrollMore = () => {
    const refLoading = useRef(false);
    const refDebounce = useRef(Date.now());
    const { conversationId, unshiftMessageList, prevError, prevHasMore, prevCursorId, setPrevInfo, setPrevError, } = useConversationStore(store => ({
        conversationId: store.id,
        unshiftMessageList: store.unshiftMessageList,
        prevError: store.prevError,
        prevHasMore: store.prevHasMore,
        prevCursorId: store.prevCursorId,
        setPrevInfo: store.setPrevInfo,
        setPrevError: store.setPrevError,
    }));
    const chatService = useApiClientStore(store => store.chatService);
    const onScrollToUpper = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        if (refLoading.current || !conversationId) {
            return;
        }
        logger.debug('onScrollToUpper currentTime', {
            currentTime: refDebounce.current,
            time: Date.now() - refDebounce.current,
        });
        if (Date.now() - refDebounce.current < 1500) {
            return;
        }
        refLoading.current = true;
        // chatService.getMessageList will never throw error, so don't need to catch error
        const _a = yield chatService.getMessageList({
            conversationId: conversationId || '',
            prevCursorId,
        }), { messages: messageList, error } = _a, rest = __rest(_a, ["messages", "error"]);
        unshiftMessageList(conversationId, messageList);
        if (error) {
            setPrevError(error);
        }
        else {
            setPrevInfo(rest.prevHasMore || false, rest.prevCursorId || '');
        }
        refDebounce.current = Date.now();
        refLoading.current = false;
    }), [prevCursorId, chatService, conversationId, unshiftMessageList]);
    return {
        prevError,
        isNeedPrevLoadMore: prevHasMore,
        upperThreshold: UPPER_THRESHOLD,
        onScrollToUpper: prevHasMore ? onScrollToUpper : undefined,
    };
};
//# sourceMappingURL=use-scroll-more.js.map