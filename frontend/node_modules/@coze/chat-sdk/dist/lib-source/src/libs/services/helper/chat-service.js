var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { logger, MiniChatError } from "../../utils";
const MESSAGE_LIST_NUM = 20;
export class ChatService {
    constructor({ apiClient, connectorId, appId, chatType }) {
        this.apiClient = apiClient;
        this.connectorId = connectorId || '999';
        this.appId = appId;
        this.chatType = chatType;
    }
    createNewConversation() {
        return __awaiter(this, void 0, void 0, function* () {
            const { id: conversationId, last_section_id: sectionId = '' } = yield this.apiClient.conversations.create({
                bot_id: this.appId,
                // @ts-expect-error -- linter-disable-autofix
                connector_id: this.connectorId,
            });
            return { conversationId, sectionId };
        });
    }
    createNewSection(conversationId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id: sectionId } = yield this.apiClient.conversations.clear(conversationId || '');
            return { sectionId };
        });
    }
    getAppInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield this.apiClient.bots.retrieve({
                    bot_id: this.appId,
                    // @ts-expect-error -- linter-disable-autofix
                    connector_id: this.connectorId,
                });
                return Object.assign({ appId: this.appId, type: this.chatType }, result);
            }
            catch (error) {
                const err = error;
                throw new MiniChatError(err.code || -1, err.message);
            }
        });
    }
    getOrCreateConversationId() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { data: conversationRes } = (yield this.apiClient.get('/v1/conversations', {
                bot_id: this.appId,
                connector_id: this.connectorId,
                page_num: 1,
                page_size: 1,
            }));
            const { id: conversationId, last_section_id: sectionId } = ((_a = conversationRes === null || conversationRes === void 0 ? void 0 : conversationRes.conversations) === null || _a === void 0 ? void 0 : _a[0]) || {};
            if (!conversationId) {
                return yield this.createNewConversation();
            }
            return { conversationId, sectionId };
        });
    }
    getMessageList({ conversationId, prevCursorId, limit = MESSAGE_LIST_NUM, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const resMessage = yield this.apiClient.conversations.messages.list(conversationId, {
                    after_id: prevCursorId || undefined,
                    limit,
                });
                return getFormatMessageListInfo(resMessage);
            }
            catch (error) {
                logger.error('Get Message Error', error);
                return {
                    prevCursorId: undefined,
                    nextCursorId: undefined,
                    prevHasMore: false,
                    nextHasMore: false,
                    messages: [],
                    error: new MiniChatError(-1, 'Get Message Error'),
                };
            }
            function getFormatMessageListInfo(resMessage) {
                const { first_id: nextCursorId, last_id: prevCursorIdNew, has_more: prevHasMore, data: messageList, } = resMessage;
                return {
                    prevCursorId: prevCursorIdNew,
                    nextCursorId,
                    prevHasMore,
                    nextHasMore: false,
                    messages: messageList.reverse(),
                };
            }
        });
    }
    asyncChat(params, options) {
        return this.apiClient.chat.stream(params, options);
    }
    upload(params, options) {
        return this.apiClient.files.upload(params, options);
    }
    translation(params, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-expect-error -- linter-disable-autofix
            return yield this.apiClient.audio.transcriptions(params, options);
        });
    }
    audioSpeech(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.audio.speech.create(params);
        });
    }
    handleErrorCode(code) {
        return __awaiter(this, void 0, void 0, function* () {
            const apiClient = this.apiClient;
            if (apiClient.isAuthErrorCode(code)) {
                return yield apiClient.refreshToken(apiClient.token);
            }
            return '';
        });
    }
}
//# sourceMappingURL=chat-service.js.map