var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx } from "react/jsx-runtime";
import { useEffect, useRef } from 'react';
import { Textarea as TaroTextarea, View, } from '@tarojs/components';
import { isMini, isWeb, logger } from "../../../utils";
import { usePersistCallback } from "../../../hooks";
import styles from './index.module.less';
export const Textarea = (_a) => {
    var { onSendTextMessage, onInputChange, placeholder } = _a, rest = __rest(_a, ["onSendTextMessage", "onInputChange", "placeholder"]);
    const { id = '' } = rest;
    const handleInputChange = usePersistCallback((val) => {
        onInputChange(val);
        if (isWeb) {
            const el = getInputElInWeb();
            if (el) {
                el.style.height = '0px';
                el.style.height = 'inherit';
            }
        }
    });
    const { onInputInit, getInputElInWeb } = useInputKeyDownOnWeb({
        inputId: id,
        onSendTextMessage,
        handleInputChange,
    });
    return (_jsx(View, Object.assign({ className: styles['input-padding-container'] }, { children: _jsx(View, Object.assign({ className: styles['input-container'] }, { children: _jsx(TaroTextarea, Object.assign({ className: styles.input, maxlength: -1, ref: onInputInit, showConfirmBar: true, controlled: true, cursorSpacing: 20, autoHeight: true, placeholder: placeholder, placeholderClass: styles.placeholder, disableDefaultPadding: true, onConfirm: () => {
                    if (isMini) {
                        onSendTextMessage();
                    }
                }, onInput: event => {
                    logger.debug('onInputKeyDown: onInput ', event.detail.value);
                    handleInputChange(event.detail.value);
                } }, rest)) })) })));
};
const useInputKeyDownOnWeb = ({ inputId, onSendTextMessage, handleInputChange, }) => {
    const refInputEl = useRef();
    const refIsComposing = useRef(false);
    const getInputElInWeb = usePersistCallback(() => {
        var _a;
        return isWeb
            ? (_a = document.getElementById(inputId)) === null || _a === void 0 ? void 0 : _a.querySelector('textarea')
            : undefined;
    });
    const onInputKeyDown = usePersistCallback((e) => {
        if (refIsComposing.current) {
            return;
        }
        if (e.code === 'Enter') {
            if (e.ctrlKey || e.metaKey || e.altKey) {
                const el = e.target;
                const start = el === null || el === void 0 ? void 0 : el.selectionStart;
                const end = el === null || el === void 0 ? void 0 : el.selectionEnd;
                const val = el === null || el === void 0 ? void 0 : el.value;
                if (start !== undefined && end !== undefined && val !== undefined) {
                    e.preventDefault();
                    e.stopPropagation();
                    const before = val.substring(0, start);
                    const after = val.substring(end);
                    el.value = `${before}\n${after}`;
                    el.selectionStart = start + 1;
                    el.selectionEnd = start + 1;
                    handleInputChange(el.value);
                }
            }
            else if (!e.shiftKey) {
                e.stopPropagation();
                e.preventDefault();
                onSendTextMessage();
            }
        }
    });
    const onCompositionstart = usePersistCallback(() => {
        //alert('compositionstart');
        refIsComposing.current = true;
    });
    const onCompositionend = usePersistCallback(() => {
        //alert('compositionend');
        refIsComposing.current = false;
    });
    const onInputInit = usePersistCallback(() => {
        if (isWeb) {
            const el = getInputElInWeb();
            refInputEl.current = el;
            el === null || el === void 0 ? void 0 : el.removeEventListener('compositionstart', onCompositionstart);
            el === null || el === void 0 ? void 0 : el.removeEventListener('compositionend', onCompositionend);
            el === null || el === void 0 ? void 0 : el.removeEventListener('keydown', onInputKeyDown);
            el === null || el === void 0 ? void 0 : el.addEventListener('keydown', onInputKeyDown);
            el === null || el === void 0 ? void 0 : el.addEventListener('compositionstart', onCompositionstart);
            el === null || el === void 0 ? void 0 : el.addEventListener('compositionend', onCompositionend);
        }
    });
    useEffect(() => {
        if (isWeb) {
            return () => {
                var _a, _b, _c;
                (_a = refInputEl.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('compositionstart', onCompositionstart);
                (_b = refInputEl.current) === null || _b === void 0 ? void 0 : _b.removeEventListener('compositionend', onCompositionend);
                (_c = refInputEl.current) === null || _c === void 0 ? void 0 : _c.removeEventListener('keydown', onInputKeyDown);
                refInputEl.current = undefined;
            };
        }
    }, []);
    return { onInputInit, getInputElInWeb };
};
//# sourceMappingURL=index.js.map