var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { RoleType } from '@coze/api';
import { convertToMinChatError, logger, MiniChatError, MiniChatErrorCode, } from "../../../../utils";
import { RawMessageType, FileTypeEnum, } from "../../../../types";
import { RawSendMessage } from './raw-send-message';
export { RawMessageType };
export class MultiSendMessage extends RawSendMessage {
    sendTextMessage(content, historyMessages) {
        const message = {
            role: RoleType.User,
            content,
            content_type: 'text',
        };
        this.sendStartMessage(message);
        this.sendMessage(message, historyMessages);
    }
    sendFileMessage(files, historyMessages) {
        return __awaiter(this, void 0, void 0, function* () {
            const content = files
                .map(item => this.packFileObject(item))
                .filter(item => !!item);
            const message = {
                role: RoleType.User,
                content: content,
                content_type: 'object_string',
            };
            this.sendStartMessage(message);
            const fileList = yield this.uploadFile(files);
            if (!fileList) {
                //失败了。
                this.sendErrorEvent(new MiniChatError(-1, this.i18n.t('sendMessageUploadFailed')));
                return;
            }
            this.messageSended.content = JSON.stringify(fileList);
            message.content = JSON.stringify(fileList.map(item => ({
                type: item.type,
                file_id: item.file_id,
            })));
            this.sendMessage(message, historyMessages);
        });
    }
    sendAudioMessage(audio, historyMessages) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            logger.info('sendAudioMessage audio', audio);
            const message = {
                role: RoleType.User,
                content: '',
                content_type: 'text',
            };
            this.sendStartMessage(Object.assign(Object.assign({}, message), { content: '', isAudioTranslatingToText: true }));
            try {
                const content = yield this.translateAudioToText(audio);
                logger.debug('sendAudioMessage content', content);
                message.content = content;
                this.sendStartMessage(Object.assign(Object.assign({}, message), { isAudioTranslatingToText: false }));
                this.sendMessage(message, historyMessages);
            }
            catch (error) {
                logger.error('sendAudioMessage', { error });
                const miniChatError = convertToMinChatError(error);
                const content = (_a = miniChatError === null || miniChatError === void 0 ? void 0 : miniChatError.getErrorMessageByI18n) === null || _a === void 0 ? void 0 : _a.call(miniChatError, this.i18n, {}, this.i18n.t('sendMessageTranslationAudioFailed'));
                this.messageSended.isAudioTranslatingToText = false;
                this.messageSended.content = content;
                this.sendErrorEvent(miniChatError);
                return;
            }
        });
    }
    translateAudioToText(audio) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.chatService.translation({
                file: {
                    filePath: audio.tempFilePath,
                    fileName: audio.fileName,
                },
            });
            if (!res.text) {
                throw new MiniChatError(MiniChatErrorCode.Audio_Translation_NoContent, this.i18n.t('sendMessageTranslationAudioNone'));
            }
            return res.text;
        });
    }
    uploadFile(file) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileList = [];
            let hasError = false;
            try {
                yield Promise.all(file.map((item) => __awaiter(this, void 0, void 0, function* () {
                    const packResult = this.packFileObject(item);
                    if (packResult) {
                        const res = yield this.chatService.upload({
                            file: item.file,
                        });
                        packResult.file_id = res.id;
                        fileList.push(packResult);
                    }
                })));
            }
            catch (error) {
                hasError = true;
            }
            return hasError ? null : fileList;
        });
    }
    getObjectStringType(fileType) {
        return fileType === FileTypeEnum.IMAGE ? 'image' : 'file';
    }
    packFileObject(fileInfo) {
        const type = this.getObjectStringType(fileInfo.type);
        switch (type) {
            case 'image': {
                return {
                    type: 'image',
                    file_url: fileInfo.tempFilePath,
                    file_info: fileInfo,
                };
            }
            case 'file': {
                return {
                    type: 'file',
                    // @ts-expect-error -- linter-disable-autofix
                    name: fileInfo.file.name,
                    // @ts-expect-error -- linter-disable-autofix
                    size: fileInfo.file.size,
                    file_url: fileInfo.tempFilePath,
                    file_info: fileInfo,
                };
            }
            default: {
                return null;
            }
        }
    }
    sendRawMessage(rawMessage, historyMessages) {
        return __awaiter(this, void 0, void 0, function* () {
            this.messageSended.rawMessage = rawMessage;
            switch (rawMessage.type) {
                case RawMessageType.TEXT: {
                    return yield this.sendTextMessage(rawMessage.data, historyMessages);
                }
                case RawMessageType.FILE: {
                    return yield this.sendFileMessage(rawMessage.data, historyMessages);
                }
                case RawMessageType.AUDIO: {
                    return yield this.sendAudioMessage(rawMessage.data, historyMessages);
                }
                default: {
                    throw new MiniChatError(-1, 'unknown message type');
                }
            }
        });
    }
}
//# sourceMappingURL=multi-send-message.js.map