import { useMemo } from 'react';
import { create } from 'zustand';
import { logger, nanoid } from "../../utils";
import { SendMessageEvent } from "../../types";
import { useUpdateEffect } from "../../hooks";
import { useChatPropsContext } from '../context';
const packMessageToGroup = (newMessageList, isForceGroup) => {
    const groups = [];
    newMessageList.map(item => {
        const groupLocalIdCur = nanoid();
        //进入这里的必需有一个localId,用于定位;
        const { chat_id: curChatId, type } = item;
        if (groups.length > 0) {
            const lastGroup = groups[groups.length - 1];
            const { chatId: lastChatId } = lastGroup;
            if (type !== 'question') {
                if (isForceGroup || (lastChatId && lastChatId === curChatId)) {
                    // 同一个对话中的消息放到一起。
                    lastGroup.respMessages.push(item);
                    return;
                }
            }
        }
        // 新的对话
        if (type !== 'question') {
            groups.push({
                id: groupLocalIdCur,
                chatId: curChatId,
                respMessages: [item],
                sectionId: item.section_id,
            });
        }
        else {
            groups.push({
                id: groupLocalIdCur,
                chatId: curChatId,
                query: item,
                respMessages: [],
                sectionId: item.section_id,
            });
        }
    });
    return groups;
};
// 两个消息的结合出，需要进行合并，因为 问题、回答可能会处于两个请求中。
const combineMessageGroup = (groupBefore, groupAfter) => {
    let messageGroupsToSave = [];
    const lastGroupInBefore = groupBefore[groupBefore.length - 1];
    const firstGroupInAfter = groupAfter[0];
    if (!(firstGroupInAfter === null || firstGroupInAfter === void 0 ? void 0 : firstGroupInAfter.query) && firstGroupInAfter) {
        // 新消息是回答，回答是一定会有chatId的。
        // 如果chatId一致，则将新消息合并到当前的消息中。
        // 如果上一个query没有chatId，就认为这两个对话被两个请求被截断了，需要合并到一起
        if ((lastGroupInBefore === null || lastGroupInBefore === void 0 ? void 0 : lastGroupInBefore.chatId) === (firstGroupInAfter === null || firstGroupInAfter === void 0 ? void 0 : firstGroupInAfter.chatId) ||
            !(lastGroupInBefore === null || lastGroupInBefore === void 0 ? void 0 : lastGroupInBefore.chatId)) {
            lastGroupInBefore.chatId = firstGroupInAfter === null || firstGroupInAfter === void 0 ? void 0 : firstGroupInAfter.chatId;
            groupAfter.shift(); // 合并后，清除上一个数据
            lastGroupInBefore.respMessages = [
                ...lastGroupInBefore.respMessages,
                ...firstGroupInAfter.respMessages,
            ];
            groupBefore[groupBefore.length - 1] = Object.assign({}, lastGroupInBefore);
        }
    }
    messageGroupsToSave = [...groupBefore, ...groupAfter];
    return messageGroupsToSave;
};
const defaultData = {
    id: '',
    sectionId: '',
    chatMessageGroups: [],
    prevCursorId: '',
    prevHasMore: false,
    prevError: undefined,
    nextCursorId: '',
    nextHasMore: false,
    nextError: undefined,
    sendMessageService: undefined,
    inProcessChatMessageGroup: undefined,
    isUnshiftingMessageFlag: false,
};
// eslint-disable-next-line max-lines-per-function
const createConversationStore = ({ eventCallbacks }) => {
    let eventCallbacksAboutMessage = eventCallbacks === null || eventCallbacks === void 0 ? void 0 : eventCallbacks.message;
    // eslint-disable-next-line max-lines-per-function
    return create()((set, get) => {
        const clearConversation = () => {
            set(Object.assign({}, defaultData));
            get().closeSendMessage();
        };
        return Object.assign(Object.assign({}, defaultData), { setEventCallbacksAboutMessage: callbacks => {
                eventCallbacksAboutMessage = callbacks;
            }, setConversationDetail: (detail, messageList) => {
                clearConversation();
                set(Object.assign(Object.assign({}, detail), { chatMessageGroups: packMessageToGroup(messageList) }));
            }, setNewConversationId: (id) => {
                clearConversation();
                // 新会话的时候，不需要向前翻页，且消息记录是空的。
                set({
                    id,
                });
            }, setSectionId: (id) => {
                set({
                    sectionId: id,
                });
            }, 
            // 处于末尾，目前只会存在于新回复消息。
            pushMessageList: (list) => {
                const curMessageGroups = get().chatMessageGroups;
                const newMessageGroups = packMessageToGroup(list);
                set({
                    chatMessageGroups: combineMessageGroup(curMessageGroups, newMessageGroups),
                });
            }, unshiftMessageList: (conversationId, list) => {
                var _a;
                const { chatMessageGroups } = get();
                const conversationIdCur = get().id;
                if (conversationId !== conversationIdCur) {
                    // 异常处理， 比如已经清空了数据，但是上一屏幕数据才到。
                    return null;
                }
                let firstAnswerMessage;
                if (chatMessageGroups[0] && !((_a = chatMessageGroups === null || chatMessageGroups === void 0 ? void 0 : chatMessageGroups[0]) === null || _a === void 0 ? void 0 : _a.query)) {
                    firstAnswerMessage = chatMessageGroups.shift();
                }
                const topChatMessageGroups = combineMessageGroup(packMessageToGroup(list), firstAnswerMessage ? [firstAnswerMessage] : []);
                set({
                    isUnshiftingMessageFlag: true,
                    chatMessageGroups: [...topChatMessageGroups, ...chatMessageGroups],
                });
            }, setPrevInfo: (prevHasMore, prevCursorId) => {
                set({
                    prevError: undefined,
                    prevHasMore,
                    prevCursorId,
                });
            }, setNextInfo: (nextHasMore, nextCursorId) => {
                set({
                    nextError: undefined,
                    nextHasMore,
                    nextCursorId,
                });
            }, isShowOnBoarding: () => {
                const { chatMessageGroups, inProcessChatMessageGroup } = get();
                return chatMessageGroups.length === 0 && !inProcessChatMessageGroup;
            }, clearUnshiftingMessageFlg: (scrollTop) => {
                set({
                    scrollTop,
                    isUnshiftingMessageFlag: false,
                });
            }, setPrevError: error => {
                set({
                    prevError: error,
                });
            }, setNextError: error => {
                set({
                    nextError: error,
                });
            }, setSendMessageService: service => {
                set({
                    sendMessageService: service,
                });
                const groupLocalId = nanoid();
                service.on(SendMessageEvent.ReceiveMessage, event => {
                    const group = packMessageToGroup(event.messages)[0];
                    logger.debug('[dev] ReceiveMessage', event.messages[event.messages.length - 1].content);
                    group.id = groupLocalId;
                    group.isAWaiting = true;
                    set({
                        inProcessChatMessageGroup: group,
                    });
                });
                service.on(SendMessageEvent.ReceiveComplete, event => {
                    var _a;
                    const { messages, error } = event;
                    set({
                        inProcessChatMessageGroup: undefined,
                    });
                    const curMessageGroups = get().chatMessageGroups;
                    let messageList = event.messages;
                    if (messages.length === 1 && error) {
                        messageList = [Object.assign(Object.assign({}, messages[0]), { error })];
                    }
                    const newGroup = packMessageToGroup(messageList, true)[0];
                    newGroup.id = groupLocalId;
                    newGroup.sectionId;
                    if (newGroup.sectionId) {
                        get().setSectionId(newGroup.sectionId || '');
                    }
                    else {
                        newGroup.sectionId = get().sectionId;
                    }
                    (_a = eventCallbacksAboutMessage === null || eventCallbacksAboutMessage === void 0 ? void 0 : eventCallbacksAboutMessage.afterMessageReceivedFinish) === null || _a === void 0 ? void 0 : _a.call(eventCallbacksAboutMessage, {
                        extra: {
                            processChatMessageGroup: newGroup,
                        },
                    });
                    set({
                        chatMessageGroups: combineMessageGroup(curMessageGroups, [
                            newGroup,
                        ]),
                    });
                });
                service.on(SendMessageEvent.Close, () => {
                    set({
                        inProcessChatMessageGroup: undefined,
                        sendMessageService: undefined,
                    });
                });
            }, closeSendMessage: () => {
                const service = get().sendMessageService;
                service === null || service === void 0 ? void 0 : service.close();
            }, popLastErrorChatGroup: () => {
                var _a, _b, _c, _d;
                const { chatMessageGroups } = get();
                if (((_b = (_a = chatMessageGroups[chatMessageGroups.length - 1]) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.error) &&
                    ((_d = (_c = chatMessageGroups[chatMessageGroups.length - 1]) === null || _c === void 0 ? void 0 : _c.query) === null || _d === void 0 ? void 0 : _d.rawMessage)) {
                    const chatGroup = chatMessageGroups.pop();
                    set({
                        chatMessageGroups,
                    });
                    return chatGroup || null;
                }
                return null;
            } });
    });
};
export const useCreateConversationStore = () => {
    var _a;
    const chatProps = useChatPropsContext();
    const conversationStore = useMemo(() => createConversationStore(chatProps), []);
    useUpdateEffect(() => {
        var _a;
        conversationStore
            .getState()
            .setEventCallbacksAboutMessage((_a = chatProps === null || chatProps === void 0 ? void 0 : chatProps.eventCallbacks) === null || _a === void 0 ? void 0 : _a.message);
    }, [(_a = chatProps === null || chatProps === void 0 ? void 0 : chatProps.eventCallbacks) === null || _a === void 0 ? void 0 : _a.message]);
    return conversationStore;
};
//# sourceMappingURL=conversation.js.map