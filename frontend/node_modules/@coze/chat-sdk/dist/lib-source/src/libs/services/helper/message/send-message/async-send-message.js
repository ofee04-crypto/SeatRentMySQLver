var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import { ChatEventType, } from '@coze/api';
import { logger, MiniChatError, safeJSONParse } from "../../../../utils";
import { Language } from "../../../../types";
import { MultiSendMessage } from './multi-send-message';
const errorCodeListToShowInMessage = ['4033', '4028', '4027', '4013'];
export class AsyncSendMessage extends MultiSendMessage {
    sendMessage(message, historyMessages) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                logger.debug('asyncChat start sendMessage: ', message);
                this._checkTimeout();
                const chatStream = yield this.chatService.asyncChat({
                    bot_id: this.botId,
                    user_id: this.userId,
                    additional_messages: [...(historyMessages || []), message],
                    conversation_id: this.conversationId,
                    connector_id: this.connectorId,
                    suggestPromoteInfo: (_a = this.chatInfo) === null || _a === void 0 ? void 0 : _a.suggestPromoteInfo,
                }, {
                    headers: {
                        'Accept-Language': this.i18n.language === Language.ZH_CN ? 'zh' : 'en',
                    },
                });
                logger.debug('asyncChat sendMessage stream: ', chatStream);
                this.chatStream = chatStream;
                this.pollAnswer();
            }
            catch (err) {
                logger.error('asyncChat sendMessage error', err);
                this.sendErrorEvent(new MiniChatError(-1, this.i18n.t('sendFailed')));
                this.close();
            }
        });
    }
    // eslint-disable-next-line max-lines-per-function, complexity
    pollAnswer() {
        var _a, e_1, _b, _c;
        var _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.chatStream) {
                logger.error('asyncChat pollAnswer', 'chatStream is undefined');
                // 这里基本不会出现，下边方便通过语法结构
                this.sendErrorEvent(new MiniChatError(-1, this.i18n.t('sendFailed')));
                return;
            }
            logger.debug('asyncChat pollAnswer awaiting start');
            const messageList = [];
            let messageInProcessing = null;
            this._checkTimeout();
            try {
                try {
                    for (var _f = true, _g = __asyncValues(this.chatStream), _h; _h = yield _g.next(), _a = _h.done, !_a;) {
                        _c = _h.value;
                        _f = false;
                        try {
                            const eventData = _c;
                            logger.debug('asyncChat pollAnswer awaiting start2', eventData);
                            this._checkTimeout();
                            if (!this.isAbort) {
                                const { event, data } = eventData;
                                /*
                                 * 未做处理消息
                                 * CONVERSATION_CHAT_REQUIRES_ACTION
                                 * CONVERSATION_CHAT_IN_PROGRESS
                                 * CONVERSATION_AUDIO_DELTA
                                 * CONVERSATION_CHAT_COMPLETED
                                 */
                                switch (event) {
                                    case ChatEventType.CONVERSATION_CHAT_CREATED:
                                        {
                                            const messageNew = safeJSONParse(eventData.data);
                                            // @ts-expect-error -- linter-disable-autofix
                                            const { id: chatId, section_id: sectionId } = messageNew || {};
                                            this.messageSended.chat_id = chatId || '';
                                            this.messageSended.section_id = sectionId;
                                            this.messageSended.extData = {
                                                // @ts-expect-error -- linter-disable-autofix
                                                executeId: data === null || data === void 0 ? void 0 : data.execute_id,
                                            };
                                            this.messageSended = Object.assign({}, this.messageSended);
                                            this.messageList = [this.messageSended, ...(messageList || [])];
                                            this.sendProcessEvent();
                                        }
                                        break;
                                    case ChatEventType.CONVERSATION_MESSAGE_DELTA:
                                        {
                                            const messageNew = safeJSONParse(data);
                                            if (!messageNew) {
                                                break;
                                            }
                                            if (!messageInProcessing) {
                                                messageInProcessing = messageNew;
                                            }
                                            else {
                                                messageInProcessing.content =
                                                    messageInProcessing.content || '';
                                                messageInProcessing.content += messageNew.content || '';
                                                if (!messageInProcessing.content ||
                                                    !messageInProcessing.reasoning_content) {
                                                    messageInProcessing.reasoning_content =
                                                        messageInProcessing.reasoning_content || '';
                                                    messageInProcessing.reasoning_content +=
                                                        messageNew.reasoning_content || '';
                                                }
                                            }
                                            messageInProcessing.isComplete = false;
                                            this.messageList = [
                                                this.messageSended,
                                                ...(messageList || []),
                                                messageInProcessing,
                                            ];
                                            this.sendProcessEvent();
                                        }
                                        break;
                                    case ChatEventType.CONVERSATION_MESSAGE_COMPLETED:
                                        {
                                            // 消息结束
                                            const messageNew = safeJSONParse(data);
                                            if (messageInProcessing) {
                                                messageInProcessing.isComplete = true;
                                                messageList.push(messageInProcessing);
                                                messageInProcessing = null;
                                            }
                                            else {
                                                if (!messageNew) {
                                                    break;
                                                }
                                                messageNew.isComplete = true;
                                                messageList.push(messageNew);
                                            }
                                            this.messageList = [this.messageSended, ...(messageList || [])];
                                            this.sendProcessEvent();
                                        }
                                        break;
                                    case ChatEventType.CONVERSATION_CHAT_REQUIRES_ACTION:
                                        {
                                            // 消息结束
                                            const actionEvent = safeJSONParse(data);
                                            this.sendRequireActionEvent(actionEvent);
                                        }
                                        break;
                                    case ChatEventType.ERROR: {
                                        const messageError = safeJSONParse(data);
                                        this.chatService.handleErrorCode(messageError.code || -1);
                                        this.sendHandledErrorEvent(messageError.code, messageError.msg, messageList);
                                        return;
                                    }
                                    case ChatEventType.CONVERSATION_CHAT_FAILED: {
                                        const messageError = safeJSONParse(data);
                                        this.sendHandledErrorEvent(((_d = messageError.last_error) === null || _d === void 0 ? void 0 : _d.code) || -1, ((_e = messageError.last_error) === null || _e === void 0 ? void 0 : _e.msg) || '', messageList);
                                        return;
                                    }
                                    case ChatEventType.DONE: {
                                        this.messageList = [this.messageSended, ...(messageList || [])];
                                        this.sendCompleteEvent();
                                        return;
                                    }
                                    default:
                                        break;
                                }
                            }
                            else {
                                return;
                            }
                        }
                        finally {
                            _f = true;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            catch (error) {
                logger.error('asyncChat pollAnswer error', error);
                this.sendErrorEvent(new MiniChatError(-1, this.i18n.t('sendFailed')));
                return;
            }
        });
    }
    sendHandledErrorEvent(errorCode, errorMsg, messageList) {
        if (errorCodeListToShowInMessage.includes(errorCode.toString()) &&
            errorMsg) {
            this.messageList = [this.messageSended, ...(messageList || [])];
            this.messageList.push(this.createAnswerTextMessage(errorMsg));
            this.sendCompleteEvent();
        }
        else {
            this.sendErrorEvent(new MiniChatError(errorCode || -1, errorMsg || this.i18n.t('sendFailed')));
        }
    }
}
//# sourceMappingURL=async-send-message.js.map