var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { useMemo, useState } from 'react';
import { isWeb, logger } from "../../../utils";
import { useI18n } from "../../../provider";
import { usePersistCallback, useUpdateEffect } from "../../../hooks";
export const useTextInputHandle = (chatInputProps, options) => {
    const i18n = useI18n();
    const { defaultValue, onSendTextMessage: onSendTextMessageOnly, disabled, } = chatInputProps;
    const { inputId, taskMessage } = options;
    const [focused, setFocused] = useState(false);
    const [inputValue, setInputValue] = useState(defaultValue);
    const toSendInputValue = useMemo(() => {
        var _a;
        if ((taskMessage === null || taskMessage === void 0 ? void 0 : taskMessage.isShow) && ((_a = taskMessage === null || taskMessage === void 0 ? void 0 : taskMessage.options) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            const taskMessageText = taskMessage === null || taskMessage === void 0 ? void 0 : taskMessage.options.map(item => item.trim()).join('; ');
            return `${i18n.t('taskMessageMyChoice')}${taskMessageText}\n${inputValue || ''}`;
        }
        return inputValue;
    }, [taskMessage, inputValue]);
    const blurInput = usePersistCallback(() => {
        var _a, _b;
        setFocused(false);
        if (isWeb) {
            // Mobile browser cannot blur the input element, need to manually blur the input element
            (_b = (_a = document.getElementById(inputId)) === null || _a === void 0 ? void 0 : _a.querySelector('textarea')) === null || _b === void 0 ? void 0 : _b.blur();
        }
    });
    const clearInput = usePersistCallback((isBlur) => {
        setInputValue('');
        isBlur && blurInput();
        // Fix taro onInput event.When the text is copied by clipboardï¼Œ it must be clear twice.
        setTimeout(() => {
            setInputValue('');
            // When input value is set, the input will be focused on miniProgram
            isBlur && blurInput();
        }, 50);
    });
    useUpdateEffect(() => {
        if (defaultValue !== undefined) {
            setInputValue(defaultValue);
        }
    }, [defaultValue]);
    const onSendTextMessage = usePersistCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        logger.debug('useTextInputHandle onSendTextMessage:', {
            inputValue,
            toSendInputValue,
            disabled,
        });
        if (toSendInputValue && !disabled) {
            if ((yield (onSendTextMessageOnly === null || onSendTextMessageOnly === void 0 ? void 0 : onSendTextMessageOnly(toSendInputValue))) === false) {
                return;
            }
            clearInput(!isWeb);
        }
    }));
    return {
        focused,
        clearInput,
        setFocused,
        inputValue,
        setInputValue,
        toSendInputValue,
        onSendTextMessage,
    };
};
//# sourceMappingURL=use-text-input-handle.js.map